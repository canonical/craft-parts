# Copyright 2025 Canonical Ltd.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License version 3 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Utilities for Maven projects and settings."""

import logging
import os
import re
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path
from typing import cast
from urllib.parse import urlparse

from typing_extensions import Self, override

from craft_parts.infos import PartInfo

from ._xml import (
    CRAFT_REPO_TEMPLATE,
    DISTRIBUTION_REPO_TEMPLATE,
    LOCAL_REPO_TEMPLATE,
    MIRROR_REPO,
    PLUGIN_TEMPLATE,
    PROXIES_TEMPLATE,
    PROXY_CREDENTIALS_TEMPLATE,
    PROXY_TEMPLATE,
    SETTINGS_TEMPLATE,
)

logger = logging.getLogger(__name__)

ArtifactDict = dict[str, set["MavenArtifact"]]
GroupDict = dict[str, ArtifactDict]
Namespaces = dict[str, str]


def create_maven_settings(*, part_info: PartInfo, set_mirror: bool) -> Path:
    """Create a Maven configuration file.

    The settings file contains additional configuration for Maven, such
    as proxy parameters and a reference to the backstage repository.

    :param part_info: The part info for the part invoking Maven.
    :param set_mirror: Whether to configure for a local build.

    :return: Returns a Path object to the newly created settings file.
    """
    settings_path = part_info.part_build_subdir / ".parts/.m2/settings.xml"
    settings_path.parent.mkdir(parents=True, exist_ok=True)

    proxies_element = _get_proxy_config() if _needs_proxy_config() else ""

    # Use artifacts generated by other parts, if they exist.
    backstage_repo = cast("Path", part_info.backstage_dir) / "maven-use"
    if backstage_repo.is_dir():
        # This is the shared repository in the backstage
        craft_element = CRAFT_REPO_TEMPLATE.format(repo_uri=backstage_repo.as_uri())
    else:
        craft_element = ""

    # The "cache" dir local to the maven run
    local_repo = part_info.part_build_subdir / ".parts/.m2/repository"
    local_element = LOCAL_REPO_TEMPLATE.format(repo_dir=local_repo)

    mirror_element = MIRROR_REPO if set_mirror else ""

    settings_xml = SETTINGS_TEMPLATE.format(
        local_repository_element=local_element,
        craft_repository_element=craft_element,
        mirror_repository_element=mirror_element,
        proxies_element=proxies_element,
    )

    settings_path.write_text(settings_xml)

    return settings_path


def _get_proxy_config() -> str:
    """Generate an XML string for proxy configurations.

    Reads the environment for information on desired proxy settings and
    transforms those variables into Maven XML settings entries.
    """
    # Transform all environment variables to their lowercase form to support HTTPS_PROXY
    # vs. https_proxy and such
    case_insensitive_env = {item[0].lower(): item[1] for item in os.environ.items()}

    proxies: list[str] = []
    for protocol in ["http", "https"]:
        env_name = f"{protocol}_proxy"
        if env_name not in case_insensitive_env:
            continue

        proxy_url = urlparse(case_insensitive_env[env_name])
        if proxy_url.username is not None and proxy_url.password is not None:
            credentials = PROXY_CREDENTIALS_TEMPLATE.format(
                username=proxy_url.username, password=proxy_url.password
            )
        else:
            credentials = ""

        proxy_element = PROXY_TEMPLATE.format(
            id=env_name,
            protocol=protocol,
            host=proxy_url.hostname,
            port=proxy_url.port,
            credentials=credentials,
            non_proxy_hosts=_get_no_proxy_string(),
        )

        proxies.append(proxy_element)

    return PROXIES_TEMPLATE.format(proxies="\n".join(proxies))


def _needs_proxy_config() -> bool:
    """Determine whether or not proxy configuration is necessary for Maven."""
    proxy_vars = ["http_proxy", "https_proxy", "HTTP_PROXY", "HTTPS_PROXY"]
    return any(key in os.environ for key in proxy_vars)


def _get_no_proxy_string() -> str:
    no_proxy = [k.strip() for k in os.environ.get("no_proxy", "localhost").split(",")]
    return "|".join(no_proxy)


def update_pom(
    *,
    part_info: PartInfo,
    deploy_to: Path | None,
    self_contained: bool,
    pom_file: Path | None = None,
) -> None:
    """Update the POM file of a Maven project.

    :param part_info: Information about the invoking part.
    :param deploy_to: The path to configure the `mvn deploy` location. If None, no path
        is configured.
    :param self_contained: Whether or not to patch version numbers with what is
        actually available.
    :param pom_file: The optional Maven POM file to update. If ``None``, the function
        will try to use ``pom.xml`` on the part's build subdir.
    """
    existing = _get_existing_artifacts(part_info)
    poms = _get_poms(pom_file, part_info, existing)

    for pom in poms:
        tree = ET.parse(pom)  # noqa: S314, unsafe parsing with xml
        project = tree.getroot()
        namespaces = _get_namespaces(project)

        if deploy_to is not None:
            # Add a distributionManagement element, to tell "maven deploy" to deploy the
            # artifacts (jars, poms, etc) to the export dir.
            distribution_dir = deploy_to / "maven-use"
            distribution_element = ET.fromstring(  # noqa: S314, unsafe parsing with xml
                DISTRIBUTION_REPO_TEMPLATE.format(repo_uri=distribution_dir.as_uri())
            )

            # Remove the existing distributionManagement tag if present.
            # This is okay because we only need to "distribute" to the backstage directory,
            # so any other project-specific config is irrelevant to this build.
            if (
                existing_distmgmt := project.find("distributionManagement", namespaces)
            ) is not None:
                project.remove(existing_distmgmt)

            project.append(distribution_element)

        if self_contained:
            MavenArtifact.update_versions(project, namespaces, existing)
            MavenPlugin.update_versions(project, namespaces, existing)
            MavenParent.update_versions(project, namespaces, existing)

        # Add a comment to record the fact that this was modified by use
        comment = ET.Comment("This project was modified by craft-parts")
        project.insert(0, comment)
        ET.indent(tree)
        tree.write(pom)


@dataclass(frozen=True)
class MavenArtifact:
    """A dataclass for Maven artifacts."""

    group_id: str
    artifact_id: str
    version: str | None
    packaging_type: str | None

    field_name: str = "Dependency"

    @classmethod
    def from_element(cls, element: ET.Element, namespaces: Namespaces) -> Self:
        """Create a MavenArtifact from an XML artifact element."""
        # We can always just set the version if it's missing, so don't raise
        try:
            version = _get_element_text(_find_element(element, "version", namespaces))
        except MavenXMLError:
            version = None

        # Attempt to read a packaging type
        try:
            packaging = _get_element_text(
                _find_element(element, "packaging", namespaces)
            )
        except MavenXMLError:
            packaging = None

        group_id = _get_element_text(_find_element(element, "groupId", namespaces))
        artifact_id = _get_element_text(
            _find_element(element, "artifactId", namespaces)
        )

        return cls(group_id, artifact_id, version, packaging)

    @classmethod
    def from_pom(cls, pom: Path) -> Self:
        """Create a MavenArtifact from a pom file."""
        tree = ET.parse(pom)  # noqa: S314, unsafe parsing with xml
        project = tree.getroot()
        namespaces = {}
        if match := re.search("{(.*)}", project.tag):
            namespace = match.group(1)
            namespaces = {"": namespace}
        return cls.from_element(project, namespaces)

    @classmethod
    def _collect_elements(
        cls, project: ET.Element, namespaces: Namespaces
    ) -> list[ET.Element]:
        dependencies = project.find("dependencies", namespaces)
        if dependencies is None:
            return []

        return dependencies.findall("dependency", namespaces)

    @classmethod
    def update_versions(
        cls, project: ET.Element, namespaces: Namespaces, existing: GroupDict
    ) -> None:
        """Update all of the versions for this project as necessary."""
        for dependency in cls._collect_elements(project, namespaces):
            dep = cls.from_element(dependency, namespaces)
            if new_version := _get_available_version(existing, dep):
                _set_version(dependency, namespaces, new_version)
            else:
                logger.debug(
                    f"{cls.field_name} {dep.artifact_id} has no available version, skipping."
                )


@dataclass(frozen=True)
class MavenParent(MavenArtifact):
    """A dataclass for the Maven parent tag."""

    field_name: str = "Parent"

    @classmethod
    @override
    def _collect_elements(
        cls, project: ET.Element, namespaces: Namespaces
    ) -> list[ET.Element]:
        parent = project.find("parent", namespaces)
        if parent is None:
            return []
        return [parent]


@dataclass(frozen=True)
class MavenPlugin(MavenArtifact):
    """A dataclass for Maven plugins.

    These are different because plugins have a default groupId.
    """

    field_name: str = "Plugin"

    @classmethod
    @override
    def from_element(cls, element: ET.Element, namespaces: Namespaces) -> Self:
        """Create a MavenPlugin from an XML plugin element.

        If no groupId is found, 'org.apache.maven.plugins' will be used.

        For more information on the default plugin group, see:
        https://maven.apache.org/guides/mini/guide-configuring-plugins.html
        """
        # We can always just set the version if it's missing, so don't raise
        try:
            group_id_element = _find_element(element, "groupId", namespaces)
        except MavenXMLError:
            group_id = "org.apache.maven.plugins"
        else:
            group_id = _get_element_text(group_id_element)

        try:
            version = _get_element_text(_find_element(element, "version", namespaces))
        except MavenXMLError:
            version = None

        artifact_id = _get_element_text(
            _find_element(element, "artifactId", namespaces)
        )

        return cls(group_id, artifact_id, version, "maven-plugin")

    @classmethod
    @override
    def _collect_elements(
        cls, project: ET.Element, namespaces: Namespaces
    ) -> list[ET.Element]:
        all_plugins = []

        # Get plugins declared at <build><plugins>
        try:
            build = _find_element(project, "build", namespaces)
            plugins = _find_element(build, "plugins", namespaces)
            all_plugins.extend(plugins.findall("plugin", namespaces))
        except MavenXMLError:
            pass

        # Get plugins declared at <build><pluginManagement><plugins>
        try:
            build = _find_element(project, "build", namespaces)
            plugin_mgmt = _find_element(build, "pluginManagement", namespaces)
            plugins = _find_element(plugin_mgmt, "plugins", namespaces)
            all_plugins.extend(plugins.findall("plugin", namespaces))
        except MavenXMLError:
            pass

        return all_plugins

    @classmethod
    @override
    def update_versions(
        cls, project: ET.Element, namespaces: Namespaces, existing: GroupDict
    ) -> None:
        """Update all of the versions for this project as necessary."""
        declared_plugins = cls._collect_elements(project, namespaces)
        existing_plugins = cls._get_existing_plugins(existing)

        # Patch the declared plugins
        patched_plugins: set[MavenArtifact] = set()
        for plugin_ele in declared_plugins:
            plugin = MavenPlugin.from_element(plugin_ele, namespaces)
            if (version := _get_available_version(existing, plugin)) is not None:
                _set_version(plugin_ele, namespaces, version)
                patched_plugins.add(plugin)
            else:
                logger.warning(
                    "Plugin '%s.%s' is declared, but is not available",
                    plugin.group_id,
                    plugin.artifact_id,
                )

        # Explicitly declare the version of every other plugin on disk to be safe
        remaining_plugins = existing_plugins - patched_plugins
        cls._set_remaining_plugins(remaining_plugins, project, namespaces)

    @classmethod
    def _get_existing_plugins(cls, existing: GroupDict) -> set[MavenArtifact]:
        """Get a list of every plugin on disk."""
        existing_plugins: set[MavenArtifact] = set()
        for group in existing.values():
            for arts in group.values():
                for art in arts:
                    if art.packaging_type == "maven-plugin":
                        existing_plugins.add(art)
                        break
        return existing_plugins

    @classmethod
    def _set_remaining_plugins(
        cls,
        remaining_plugins: set[MavenArtifact],
        project: ET.Element,
        namespaces: Namespaces,
    ) -> None:
        """Append remaining plugin dependency entries to a project."""
        plugins_ele = cls._get_plugins_ele(project, namespaces)
        for plugin in remaining_plugins:
            plugin_str = PLUGIN_TEMPLATE.format(
                artifact_id=plugin.artifact_id,
                group_id=plugin.group_id,
                version=plugin.version,
            )
            plugin_ele = ET.fromstring(plugin_str)  # noqa: S314
            plugins_ele.append(plugin_ele)
            ET.indent(plugins_ele, level=3)

    @classmethod
    def _get_plugins_ele(
        cls, project: ET.Element, namespaces: Namespaces
    ) -> ET.Element:
        build = _find_or_create_ele(project, "build", namespaces)
        ET.indent(project, level=0)
        plugin_mgmt = _find_or_create_ele(build, "pluginManagement", namespaces)
        ET.indent(build, level=1)
        plugins = _find_or_create_ele(plugin_mgmt, "plugins", namespaces)
        ET.indent(plugin_mgmt, level=2)
        return plugins


def _find_or_create_ele(
    element: ET.Element, tag: str, namespaces: Namespaces
) -> ET.Element:
    """Find a subelement within a given element."""
    try:
        result = _find_element(element, tag, namespaces)
    except MavenXMLError:
        result = ET.Element(tag)
        element.append(result)

    return result


def _get_existing_artifacts(part_info: PartInfo) -> GroupDict:
    result: GroupDict = GroupDict()

    search_locations = [
        part_info.backstage_dir / "maven-use",
        Path("/usr/share/maven-repo"),
    ]
    for loc in search_locations:
        if not loc.is_dir():
            continue
        for pom in loc.glob("**/*.pom"):
            art = MavenArtifact.from_pom(pom)
            _insert_into_existing(result, art)

    return result


def _get_available_version(
    existing: GroupDict, dependency: MavenArtifact
) -> str | None:
    if versions := existing.get(dependency.group_id, {}).get(
        dependency.artifact_id, set()
    ):
        return next(iter(versions)).version
    return None


def _set_version(element: ET.Element, namespaces: Namespaces, new_version: str) -> None:
    group_id = _get_element_text(_find_element(element, "groupId", namespaces))
    artifact_id = _get_element_text(_find_element(element, "artifactId", namespaces))

    version_element = element.find("version", namespaces)

    # If no version is specified at all, always set it
    if version_element is None:
        new_version_element = ET.Element("version")
        new_version_element.text = new_version
        element.append(new_version_element)
        comment = ET.Comment(f"Version set by craft-parts to '{new_version}'")
        element.append(comment)
        logger.debug(
            "Setting version of '%s.%s' to '%s'",
            group_id,
            artifact_id,
            new_version,
        )
        return

    current_version = _get_element_text(version_element)

    if current_version == new_version:
        return

    version_element.text = new_version

    comment = ET.Comment(
        f"Version updated by craft-parts from '{current_version}' to '{new_version}'"
    )
    logger.debug(
        "Updating version of '%s.%s' from '%s' to '%s'",
        group_id,
        artifact_id,
        current_version,
        new_version,
    )
    element.append(comment)
    ET.indent(element, level=2)


@dataclass
class MavenXMLError(BaseException):
    """An error encountered while parsing XML for Maven projects."""

    message: str
    details: str | None = None

    def __str__(self) -> str:
        return f"{self.message}\n{self.details}"


def _find_element(
    element: ET.Element, path: str, namespaces: dict[str, str]
) -> ET.Element:
    """Find a field within an element.

    This is equivalent to `element.find(path, namespaces)`, except that
    an exception is raised if the needle isn't found to reduce boilerplate.

    :param element: The haystack to search.
    :param path: The needle to find in the haystack.
    :param namespaces: A mapping of namespaces to use during the search.
    :raises MavenXMLError: if the needle can't be found.
    :return: The discovered element.
    """
    if (needle := element.find(path, namespaces)) is not None:
        return needle

    raise MavenXMLError(
        message=f"Could not find path {path!r} in element {element.tag!r}",
        details=f"Could not find path {path!r} in the following XML element:\n{_format_xml_str(element)}",
    )


def _get_element_text(element: ET.Element) -> str:
    """Extract the text field from an element.

    This is equivalent to `element.text`, except that an exception is
    raised if the text field is empty to reduce boilerplate.

    :param element: The element to read from.
    :raises _MavenXMLError: if there is no text field.
    :return: The content of the text field.
    """
    if (text := element.text) is not None:
        return text

    raise MavenXMLError(
        message=f"No text field found on {element.tag!r}",
        details=f"No text field found on {element.tag!r} in the following XML element:\n{_format_xml_str(element)}",
    )


def _format_xml_str(element: ET.Element) -> str:
    """Get a nicely-formatted string for displaying an XML element."""
    ET.indent(element)
    return ET.tostring(element).decode(errors="replace")


def _get_namespaces(project: ET.Element) -> Namespaces:
    """Find and register the first XML namespace."""
    namespace = re.search("{(.*)}", project.tag)
    # Older pom files may not contain a namespace
    namespaces = {"": namespace.group(1)} if namespace else {}
    for prefix, uri in namespaces.items():
        ET.register_namespace(prefix, uri)
    return namespaces


def _get_poms(
    base_pom: Path | None, part_info: PartInfo, existing: GroupDict
) -> list[Path]:
    """Get a list of poms on a project.

    Each submodule is added to the list of existing artifacts because Maven's build
    process will determine the correct order to build dependencies before their
    consuming binaries need them - we do not need to figure this out ourselves. If
    a build somehow fails due to one of these missing from the backstage, it is due
    to a malformed pom.xml.
    """
    poms: list[Path] = []

    if base_pom is None:
        base_pom = part_info.part_build_subdir / "pom.xml"

    if not base_pom.is_file():
        raise MavenXMLError("'pom.xml' does not exist")
    poms.append(base_pom)

    _recurse_submodules(part_info, base_pom, poms, existing)

    logger.debug(
        "Discovered poms for part '%s': [%s]",
        part_info.part_name,
        ", ".join(
            [str(path.relative_to(part_info.part_build_subdir)) for path in poms]
        ),
    )

    return poms


def _recurse_submodules(
    part_info: PartInfo, parent_pom: Path, all_poms: list[Path], existing: GroupDict
) -> None:
    """Recursively find submodule poms and add them to the existing artifacts."""
    tree = ET.parse(parent_pom)  # noqa: S314, unsafe parsing with xml
    project = tree.getroot()
    namespaces = _get_namespaces(project)

    # Check if there are any modules and end recursion early if not
    try:
        modules = _find_element(project, "modules", namespaces)
    except MavenXMLError:
        return

    # For every module found:
    for module in modules.findall("module", namespaces):
        # - Append it to the list of poms that need patching
        path_str = _get_element_text(module)
        pom_path = (parent_pom.parent / path_str / "pom.xml").resolve()

        # - Validate that it is a legitimate dependency file, but only warn if not
        if not pom_path.is_file():
            logger.debug(
                "The pom '%s' declares a submodule at '%s', but this submodule could not be found.",
                parent_pom.relative_to(part_info.part_build_subdir),
                path_str,
            )
            continue

        all_poms.append(pom_path)

        # - Add it to the list of existing artifacts
        art = MavenArtifact.from_pom(pom_path)
        _insert_into_existing(existing, art)

        # - Recurse on its pom.xml for more submodules
        _recurse_submodules(part_info, pom_path, all_poms, existing)


def _insert_into_existing(existing: GroupDict, art: MavenArtifact) -> None:
    """Insert a pom file into the list of existing artifacts."""
    group_artifacts = existing.setdefault(art.group_id, {})
    versions = group_artifacts.setdefault(art.artifact_id, set())
    versions.add(art)
